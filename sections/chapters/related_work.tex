\chapter{Related Work}
\label{ch:related_work}
While bit blasting (as described in the previous chapter) is the predominant approach for solving the QF\_BV theory and related theories, many approaches are being combined today in order to avoid bitblasting entire instances.
In this chapter a multitude of approaches used for solving the bitvector theory as well as solving related theories are being summarized. 

\section{Counterexample-Guieded abstractrion refinement (CEGAR)}
Counterexample-Guided abstraction refinement (CEGAR) was first proposed in the field of Software verification for the problem of verifying whether a given program $P$ adhears to some specification $\psi$ \cite{CEGAR}.\\
Given some program $P$ containing variables $V=\{v_1,\dots,v_n\}$ in domains $D_{v_1},\dots,D_{v_n}$ the set $D=D_{v_1}\times\dotsi\times D_{v_n}$ is the set of states of $P$. Let $p$ be some predicate then $\text{Atoms}\left(p\right)$ is the set of atomic formulae in $p$ and $\text{Atoms}\left(P\right)$ therefore is the set of atomic formulae in $P$. If some program state $d\in D$ satisfies some predicate $p$ we will write $d\vDash p$. A program defined this way can be directly transformed into a labeled Kripke-Structure $\mathcal{M}=\left(S,I,R,L\right)$ with $S=D$, $I\subseteq I$, $R \subseteq S \times S$, $L\colon S \to 2^{\text{Atoms}\left(P\right)}$ where $L\left(d\right) = \{ f \in \text{Atoms}\left(P\right) \mid d \vDash f \}$. The objective is then to compute whether $\mathcal{M}\vDash\psi$ id est whether the $P$'s Kripke-Structure $\mathcal{M}$ satisfies the specification $\psi$
\paragraph{Abstractions}
An abstraction in the CEGAR sense is a surjection $h\colon D \to \hat{D}$. An abstraction $h$ induces an equivalence relation of the form $d \equiv_h e$ iff $h\left(d\right) = h\left(e\right)$. Given a Kripke structure $\mathcal{M}$ and an abstraction $h$ the \textit{abstracted Kripke Structure} $\hat{\mathcal{M}} = \left(\hat{S},\hat{I},\hat{R},\hat{L}\right)$ is defined with:
\begin{itemize}
    \item $\hat{S} = \hat{D}$
    \item $\hat{d} \in \hat{I}$ iff $\exists d \in I\colon h\left(d\right) = \hat{d}$
    \item $\hat{R}\left(\hat{d_1},\hat{d_2}\right)$ iff $\exists d_1,d_2 \in D\colon h\left(d_1\right) = \hat{d_1} \land h\left(d_2\right) = \hat{d_2} \land R\left(d_1, d_2\right)$
    \item $\hat{L}\left(\hat{d}\right)=\bigcup\limits_{h\left(d\right)=\hat{d}} L\left(d\right)$
\end{itemize}

\begin{theorem}
    \label{theorem:related_work:cegar:sat}
    Let $h$ be an abstraction and $\psi$ some specification.
    Given that for every atomic formula $f$ in $\psi$ and for all $d,d' \in D$ the property $\left(d \equiv_h d'\right) \implies \left( d \vDash f \Leftrightarrow d' \vDash f \right)$ holds (we call this \enquote{$f$ respects $h$}), then:\\
    \begin{itemize}
        \item[(i)] $\hat{L}\left(\hat{d}\right)$ is consistent for all abstract states $\hat{d}$ in $\hat{M}$
        \item[(ii)] $\hat{\mathcal{M}}\vDash\psi \implies \mathcal{M} \vDash \psi$
    \end{itemize}
\end{theorem}
Do note that while correctness (as defined by $\psi$) of the abstract model $\hat{\mathcal{M}}$ implies correctness of the original model $\mathcal{M}$ a model might still be correct if $\hat{\mathcal{M}} \nvDash \psi$.

\paragraph{Initial abstraction}
Upon initialization of the solving process an initial abstraction $h$ is generated by grouping the variables $V=\{v_1,\dots,v_n\}$ into disjoint variable clusters $V = VC_1 \Dot{\cup} \dotsi \Dot{\cup} VC_n$. A variable cluster with variable $v_i$ contains any other variables $v_j$ which appear in the same atomic formulae as $v_i$ - clearly this induces an equivalence relation relation on the variables. For each variable cluster $VC_i=\{v_{i_1},\dots,v_{i_k}\}$ an abstraction is defined through:
\begin{flalign*}
   & h_i\left(d_1,\dots,d_k\right) = h_i\left(e_1,\dots,e_k\right)
    \text{ iff for all atomic formulae $f$}\\
    &\left(d_1,\dots,d_k\right) \vDash f \iff \left(e_1,\dots,e_k\right) \vDash f
\end{flalign*}

\paragraph{Handling counter examples}
If the solver returns that $\hat{\mathcal{M}} \vDash \psi$ theorem \ref{theorem:related_work:cegar:sat} tells us that $\mathcal{M} \vDash \psi$. Otherwise the solver is assumend to return a counter example that can be checked on its \textit{correctness}. More precisely it is necessary to check whether the counterexample is only possible in the abstracted structure $\hat{\mathcal{M}}$ or not. If the counterexample is caused by the abstraction a refinement step is made detailing the previous abstractions and the solver is run again on this less-abstracted version of the problem \cite{CEGAR}.
\paragraph{}
Ever since its introduction this approach of abstracting and refining has been used in wide range of applications as the core idea can be transferred onto many other problems


%\section{STP}

\section{Boolector and Lemmas on Demand}
With Boolector \cite{Brummayer-Biere2009_Chapter_BoolectorAnEfficientSMTSolverF} another approach to over-approximation called \textit{Lemmas on Demand} was introduced. Boolector uses this for both solving array theory problems \cite{p6-brummayer} and uninterpreted function theory problem \cite{NiemetzPreinerBiere-FMCAD14}. Additionally Boolector makes heavy use of rewriting to solve easy bitvector theory instances - sometimes without using a backend SAT solver at all.

\paragraph{Under-Approximation}
Boolector makes use of under-approximation on the CNF level by adding assumptions to the SAT solver instance\cite{Brummayer-PhD}. This way the effective width of a given bitvector is restricted to a smaller size which is then sign extended to reach the original bitsize. Using a newly introduced assumption variable $e$ this behaviour can be (de)activated as needed each run through the SAT solvers assumption interface. On the one hand the additional constraints reduce the search-space size and thereby helps to potentially speed up the search space. On the other hand the additional constraints help by returning smaller, usually better understandable models.

\todo{Something on Lemmas on Demand, potentially something on other Boolector stuff: rewriting?}

\section{UCLID}
Interleaving under- and overapproximations
Works for extracting unsat cores of under approximations that might be able to produce a contradiction in main problem
-> We will soon see that this methodology does not work for some of the concerned problems (specifically this methodology wouldn't yield good results for modmul given its the core size)
