\chapter{Refinement approach}
In this chapter we present a per-function-application abstraction procedure for the quantifier free bitvector theory (\texttt{QF\_BV}).
The approach substitutes applications of specific functions (here \texttt{bvmul}, \texttt{bvsdiv} and \texttt{bvsrem}) by \textit{abstractions} defined on the \texttt{QF\_UFBV} theory.
During the solving process, an instance's abstractions are iteratively refined until the SAT solver either returns unsatisfiability or satisfiability with sound variable assignments.

\section{Abstraction Scheme}
In the SMT-LIB standard \cite{BarFT-SMTLIB} for \texttt{QF\_BV} the functions examined in this work (i.e. \texttt{bvmul}, \texttt{bvsdiv} and \texttt{bvsrem}) support \textit{overloading} in the sense that a single function symbol like \texttt{bvmul} supports multiple ranks as multiplication for example is supported for any bitwidth.
To simplify the explanations in the following sections we will define $\texttt{bvmul}^r$ as the \texttt{bvmul} operation of rank $r$.

\begin{definition}[Approximation]
Given some theory $T=\left(\Sigma,A\right)$ and some function symbol $\texttt{op}\in\Sigma^F$ with $\mathcal{s}^F\left(\texttt{op}\right)=\sigma_1\dotsi\sigma_n\sigma$ and $n\geq1$ a $T$-approximation for \texttt{op} consists of:
\begin{itemize}
    \item A new uninterpreted function symbol $ap_{\texttt{op}}$ with $\mathcal{s}^F\left(\texttt{op}\right) = \mathcal{s}^F\left(ap_{\texttt{op}}\right)$
    \item A mapping $\mathcal{A}_{\texttt{op}}\colon \textsc{Term}^\Sigma_{\sigma_1}\times\dotsi\times\textsc{Term}^\Sigma_{\sigma_n} \to 2^{\textsc{For}^1_T}$
\end{itemize}
A $T$-approximation can therefore be written as a tuple $\left(ap_{\texttt{op}}, \mathcal{A}_{\texttt{op}}\right)$
\end{definition}
We can now define properties that a $T$-approximation might have. This will be useful to proof the correctness of our abstraction procedure later on

\begin{definition}[Sound $T$-approximation]
Given some theory $T=\left(\Sigma,A\right)$ a $T$-approximation $\left(ap_{\texttt{op}}, \mathcal{A}_{\texttt{op}}\right)$ is sound iff for any $\overline{x}\in Dom\left(\mathcal{A}_{\texttt{op}}\right)$ the following property holds\footnote{$Dom$ is the domain of a given function. In this case $Dom\left(\mathcal{A}_{\texttt{op}}\right) = \textsc{Term}^\Sigma_{\sigma_1}\times\dotsi\times\textsc{Term}^\Sigma_{\sigma_n}$}:\\
For any $T$-interpretation $\mathcal{I}$ with $\mathcal{I}\vDash\mathcal{A}_{\texttt{op}}\left(\overline{x}\right)$:
$\mathcal{I}\vDash ap_{\texttt{op}}\left(\overline{x}\right) \doteq \texttt{op}\left(\overline{x}\right)$
\end{definition}

\begin{definition}[Correct $T$-approximation]
Given some theory $T=\left(\Sigma,A\right)$ a $T$-approximation $\left(ap_{\texttt{op}}, \mathcal{A}_{\texttt{op}}\right)$ is correct iff for any $\overline{x}\in Dom\left(\mathcal{A}_{\texttt{op}}\right)$ the following property holds:\\
For any $T$-interpretation $\mathcal{I}$ with $\mathcal{I}\vDash ap_{\texttt{op}}\left(\overline{x}\right) \doteq \texttt{op}\left(\overline{x}\right)$:
$\mathcal{I}\vDash\mathcal{A}_{\texttt{op}}\left(\overline{x}\right)$
\end{definition}

\begin{example}
For readability let $\texttt{f} \coloneqq \texttt{mul}^{\mathbf{BV}_2\mathbf{BV}_2\mathbf{BV}_2}$ be the 2-bit multiplication function as defined in \texttt{QF\_BV}.\\
Example for a sound approximation:
\[
    \mathcal{A}_\texttt{f}\left(x_1,x_2\right) 
    \coloneqq \{
    ab_\texttt{f}\left(x_1,x_2\right) \doteq 0, \left(x_1\doteq 0 \lor x_2 \doteq 0\right)
    \}
\]
Example for a correct approximation:
\[
    \mathcal{A}_\texttt{f}\left(x_1,x_2\right) 
    \coloneqq \{
    \left(x_1\doteq 0 \lor x_2 \doteq 0\right) \implies ab_\texttt{f}\left(x_1,x_2\right) \doteq 0
    \}
\]
Example for a sound and correct approximation:
\[
\mathcal{A}_\texttt{f}\left(x_1,x_2\right) 
        \coloneqq \{
        ab_\texttt{f}\left(x_1,x_2\right) \doteq \texttt{f}\left(x_1,x_2\right)
        \}
\]
\end{example}
Essentially a sound $T$-approximation describes an under-approximation and a correct $T$-approximation describes an over-approximation of some function \texttt{op}. Using the notions defined above we can now define an abstraction scheme which iteratively refines an over-approximation until the abstraction converges into an exact description of the given function \texttt{op}.
\begin{definition}[Abstraction Scheme]
Given some theory $T=\left(\Sigma,A\right)$ and some function symbol $\texttt{op}\in\Sigma^F$ of arity greater $0$, a $T$-abstraction scheme is a finite, totally ordered set of $\ T$-approximations \[
\mathcal{AS}_{\texttt{op}} = \{ \left(ab_{\texttt{op}}, \mathcal{A}^1_{\texttt{op}}\right),\dots,\left(ab_{\texttt{op}}, \mathcal{A}^k_{\texttt{op}}\right) \}
\]
where:
\begin{itemize}
    \item For every $i\in\llbracket1,k\rrbracket$: $\mathcal{A}^i_{\texttt{op}}$ is a correct $T$-approximation of \texttt{op}
    \item $\mathcal{C}_{\texttt{op}}\left(\overline{x}\right)\coloneqq\left(\bigcup\limits_{\mathcal{A}\in\mathcal{AS}_{\texttt{op}}} \mathcal{A}\left(\overline{x}\right)\right)$ is a sound $T$-approximation of \texttt{op}
    \footnote{
        Just like all previous $T$-approximations $\mathcal{C}_{\texttt{op}}$ is defined as
        $\mathcal{C}_{\texttt{op}}\colon \textsc{Term}^\Sigma_{\sigma_1}\times\dotsi\times\textsc{Term}^\Sigma_{\sigma_n} \to 2^{\textsc{For}^1_T}$ for a function symbol \texttt{op} of rank $\sigma_1\dotsi\sigma_n\sigma$
    }
\end{itemize}
\end{definition}

\begin{lemma}
Given some $T$-approximation scheme 
$\mathcal{AS}_{\texttt{op}} = \{ \left(ab_{\texttt{op}}, \mathcal{A}^1_{\texttt{op}}\right),\dots,\left(ab_{\texttt{op}}, \mathcal{A}^k_{\texttt{op}}\right) \}$
with the properties defined above we can show that:\\
$\mathcal{C}_{\texttt{op}}$ is a correct $T$-approximation of \texttt{op}.
\begin{proof}
Let $\overline{x}$ be an arbitrary input vector for \texttt{op}.\\
By definition we know that for any $T$-interpretation $\mathcal{I}$ with $\mathcal{I} \vDash ap_{\texttt{op}}\left(\overline{x}\right) \doteq \texttt{op}\left(\overline{x}\right)$ there is also $\mathcal{I} \vDash \mathcal{A}^i_{\texttt{op}}\left(\overline{x}\right)$ for all $i\in\llbracket1,k\rrbracket$ as all approximations $\mathcal{A}^i_{\texttt{op}}$ are correct.\\
Therefore $\mathcal{I} \vDash \bigcup\limits_{\mathcal{A}\in\mathcal{AS}_{\texttt{op}}} \mathcal{A}\left(\overline{x}\right)$ (i.e. $\mathcal{I} \vDash \mathcal{C}_{\texttt{op}}\left(\overline{x}\right)$) which implies that $\mathcal{C}_{\texttt{op}}$ is a correct $T$-approximation, too.
\end{proof}
\end{lemma}

\begin{lemma}
\todo{Show that implication is enough for correctness and soundness through $A\vDash B$ iff $\vDash A \implies B$}
\end{lemma}

\begin{theorem}
\label{theorem:abstractions:scheme:equivalence}
Let $T=\left(\Sigma,A\right)$ be some signature with $\texttt{op}\in\Sigma^F$, $\mathcal{s}^F\left(\texttt{op}\right)=\sigma_1\dotsi\sigma_n\sigma$ and $n\geq1$.\\
Let further $\Phi$ be an arbitrary $\Sigma$-formula containing some function application $\texttt{op}\left(\overline{x}\right)$.\\
Given some term $t\in\textsc{Term}_\sigma^\Sigma$ we define $\Phi\left[\texttt{op}\left(\overline{x}\right)\mapsto t \right]$ as the formula where $\texttt{op}\left(\overline{x}\right)$ was replaced by $t$ in $\phi$.\\
For any $T$-abstraction scheme $\mathcal{AS}_{\texttt{op}}$ with function symbol $ap_{\texttt{op}}$ the following property holds:\\
A $T$-interpretation $\mathcal{I}$ is a $T$-model for $\Phi$ iff $\mathcal{I}$ is a $T$-model for 
\[
\Phi\left[ \texttt{op}\left(\overline{x}\right) \mapsto ab_{\texttt{op}}\left(\overline{x}\right) \right] \land \bigwedge\limits_{\mathcal{A}\in\mathcal{AS}_{\texttt{op}}} \mathcal{A}\left(\overline{x}\right)
\]
\begin{proof}
\todo{Proof through Lemma 5.1.6 and definition}
\end{proof}
\end{theorem}

\paragraph{Abstraction approach}
In the following sections abstraction schemes for 3 function symbols of the \texttt{QF\_BV} theory will be presented. In order to proof that the abstractions are actually valid we will:
\begin{itemize}
    \item[(A)] Proof the correctness of any approximation proposed
    \item[(B)] Proof the soundness of each abstraction scheme
\end{itemize}
As can be seen in theorem \ref{theorem:abstractions:scheme:equivalence} this will enough to proof that the abstraction schemes are valid.




































\chapter{OLD Refinement approach}
\todo{Remove this once new version is done!}
\label{ch:refinement_approach}
In this work we present a per-operation refinement approach for the quantifier free bitvector theory (QF\_BV) which substitutes specific operations (e.g. \texttt{bvmul}, \texttt{bvsdiv} or \texttt{bvsrem}) by abstracted versions of them in QF\_UFBV theory and then refines its constraints iteratively until the underlying SMT-Solver either returns unsatisfiability or satisfiability with sound variable assignments. We thereby hope to speedup the decision procedure for problems which are currently \enquote{hard} to solve.

\section{Abstraction Scheme}
\label{sec:refinement_approach:abstraction_scheme}
\todo{Recheck in what way this is the same as CEGAR}
For each SMT-LIB instruction \texttt{op} (e.g. \texttt{bvmul}) that we want to abstract we define uninterpreted functions $ab_{\texttt{op}}^w\left(\dots\right)$ for each $w\in W$ where $W$ are the bitwidth sorts in which \texttt{op} appears.
Given an SMT-LIB input formula $\phi$ we can then substitute each invocation of the form \texttt{(op arg\_1 \dots arg\_n)} by the invocation of the uninterpreted function $ab_{\texttt{op}}^w\left(\texttt{arg\_1}, \dots, \texttt{arg\_n}\right)$.

We define $\hat{\phi}$ as the formula $\phi$ in which all appearances of relevant operations \texttt{op} have been replaced by their abstractions $ab_\texttt{op}^w$.\\

\begin{definition}{Abstraction}
For each instruction \texttt{op} and for each bitwidth $w\in W$  we further define a set of formulas
\[\mathcal{A}_\texttt{op}^w \subset \{f \in \mathcal{F}_{QF\_UFBV} \mid \left( ab_{\texttt{op}}^w\left(\texttt{arg\_1}, \dots, \texttt{arg\_n}\right)=\texttt{(op arg\_1 \dots arg\_n)} \right) \Rightarrow f\}\]
with a total order
\[\mathcal{A}_\texttt{op}^w  = \{a_1, \dots, a_m\}\]
such that
\[\bigwedge\limits_{a\in\mathcal{A}_\texttt{op}^w} a \Rightarrow \left(ab_{\texttt{op}}^w\left(\texttt{arg\_1}, \dots, \texttt{arg\_n}\right)=\texttt{(op arg\_1 \dots arg\_n)}\right)\]
We call the set $\mathcal{A}_\texttt{op}^w$ the abstraction of \texttt{op} with bitwidth $w$.
\end{definition}

\begin{lemma} Equivalence of abstraction
\label{lemma:refinement_approach:abstraction_scheme:equivalence}
\begin{enumerate}
    \item \label{lemma:refinement_approach:abstraction_scheme:equivalence:1} Given a formula $\phi$ with exactly one appearance of the instruction \texttt{op} with bitwidth $w$ as defined above:
    \[
        \bigwedge\limits_{a\in\mathcal{A}_\texttt{op}^w} a \land \hat{\phi}
    \]
    has a model iff $\phi$ has a model
    \item For multiple appearances of \texttt{op} or appearances of multiple different instructions \texttt{op}, \texttt{op'}, \dots we can show the same result iteratively by substituting one instruction after another
\end{enumerate}
%% TODO: \begin{proof}
We only proof 1 as 2 is a trivial result of 1
\begin{itemize}
    \item[$\Leftarrow$]
    We assume there is a model $\mathcal{M}$ for which $\phi$ is true. In this case we can extend the model of $\phi$ by defining a model $\mathcal{M}'$ with $ab_\texttt{op}^w$ acting just like the operation \texttt{op}. In this case $\hat{\phi}$ is obviously satisfiable with the model $\mathcal{M}'$ and all $a \in \mathcal{A}_\texttt{op}^w$ are satisfiable by definition as $\left( ab_{\texttt{op}}^w\left(\texttt{arg\_1}, \dots, \texttt{arg\_n}\right)=\texttt{(op arg\_1 \dots arg\_n)} \right)$ is true in $\mathcal{M}'$.
    \item[$\Rightarrow$]
    We assume a model $\mathcal{M}$ for which $\hat{\phi}$ and all $a \in \mathcal{A}_\texttt{op}^w$ are true.
    By definition of $\mathcal{A}_\texttt{op}^w$ we know that $\left( ab_{\texttt{op}}^w\left(\texttt{arg\_1}, \dots, \texttt{arg\_n}\right)=\texttt{(op arg\_1 \dots arg\_n)} \right)$ is true as well for model $\mathcal{M}$.
    This again implies that $\mathcal{M}$ is also a model for $\phi$ as the results of $ab_\texttt{op}^w$ and \texttt{op} are indistinguishable in its results.
\end{itemize}
%%\end{proof}
\end{lemma}

With those basic definitions at hand one can construct simple (Algorithm \ref{algorithm:refinement_approach:abstraction_scheme:refinement}) or arbitrarily complicated, heuristic  refinement decision procedures which make use of the above mentioned abstractions. In the following sections we will look at abstractions of various SMT-LIB instructions which will then be evaluated in the next chapter.

\begin{algorithm}
    \caption{Decision procedure for QF\_BV abstractions}
    \begin{algorithmic}
    \label{algorithm:refinement_approach:abstraction_scheme:refinement}
    \REQUIRE $\phi \in \mathcal{F}_{QF\_BV}$
    \STATE abstractions$ \leftarrow \langle\rangle$
    \STATE operations$ \leftarrow \langle\rangle$
    \FORALL{\texttt{op} in $\phi$}
        \IF{\texttt{op} needs refinement}
            \STATE Replace \texttt{op} by $ab_\texttt{op}^w$
            \STATE abstractions.push$\left(\mathcal{A}_\texttt{op}^w\right)$
            \STATE operations.push$\left(\texttt{op}\right)$
        \ENDIF
    \ENDFOR
    \STATE \texttt{ADD\_CLAUSES($\phi$)}
    \LOOP
    \STATE $r \leftarrow $\texttt{SAT($\phi$)}
    \IF{\NOT $r$}
        \PRINT unsat
    \ELSE
        \STATE sound $\leftarrow \TRUE$
        \FORALL{\texttt{op} in operations}
            \IF{\NOT \texttt{op} assignment is sound}
                \STATE sound $\leftarrow \FALSE$
            \ENDIF
        \ENDFOR
        \IF{sound}
            \PRINT sat
        \ELSE
            \FORALL{A in $l1$}
                \STATE \texttt{ADD\_CLAUSES(A.pop())}
            \ENDFOR
        \ENDIF
    \ENDIF
    \ENDLOOP
    \end{algorithmic}
\end{algorithm}

\section{Refining \texttt{bvmul}}
\label{sec:refinement_approach:bvmul}
Generally speaking we considered three different approaches for abstracting the \texttt{bvmul} instruction which work on different levels.
\paragraph{Handling overflows}
For two of the proposed abstractions we will need a way of estimating whether or not the multiplication will produce an overflow. We will concentrate on providing constraints and abstractions for the cases for which we can be sure that no overflow happens and ignore the cases where an overflow might happen as the overflow cases are harder to predict in the abstraction schemes detailed below. For underestimating the set of non-overflow cases we use a method proposed in \cite[p. 32f]{Warren-HackersDelight} which counts the number of leading zeros/ones in the factors of the multiplication. The estimate of multiplication overflow for vectors of width $w$ can be split into 3 distinct cases:
\begin{itemize}
    \item Both factors are positive\\
    In this case $w$ leading zeros are sufficient
    \item One factor is negative\\
    In this case $w+1$ leading zeros/ones are sufficient
    \item Both factors are negative\\
    In this case $w+2$ leading ones are sufficient
\end{itemize}
This gives rise to the predicate in Definition \ref{def:refinement_approach:bv_mul:noov} that we'll be using to provide constraints for all cases in which no overflow happens.
\begin{definition}{$noov$}
\label{def:refinement_approach:bv_mul:noov}
We define a Boolean function $noov: \{0,1\}^w \times \{0,1\}^w \rightarrow \{0,1\}$ with
\begin{align*}
noov\left(a, b\right)
    = &\bigvee\limits_{n=0}^{w}
        \left(
        \bigwedge\limits_{i=1}^{n} \neg a[w-i]
        \land
        \bigwedge\limits_{i=n}^{w-1} \neg b[i]
        \right) \lor\\
       &\bigvee\limits_{n=0}^{w-1}
        \left(
        \bigwedge\limits_{i=1}^{n} a[w-i-1]
        \land
        \bigwedge\limits_{i=n}^{w-2} \neg b[i]
        \land a[w-1]
        \land \neg b[w-1]
        \right) \lor\\
      &\bigvee\limits_{n=0}^{w-1}
        \left(
        \bigwedge\limits_{i=1}^{n} \neg a[w-i-1]
        \land
        \bigwedge\limits_{i=n}^{w-2} b[i]
        \land \neg a[w-1]
        \land  b[w-1]
        \right) \lor\\
      &\bigvee\limits_{n=0}^{w-2}
        \left(
        \bigwedge\limits_{i=1}^{n} a[w-i-2]
        \land
        \bigwedge\limits_{i=n}^{w-3} b[i]
        \land a[w-1]
        \land b[w-1]
        \land a[w-2]
        \land b[w-2]
        \right)
\end{align*}
\end{definition}
\subsection{Simple cases}
\label{subsec:refinement_approach:bvmul:simple}
For a multiplication $ab^w_\texttt{bvmul}\left(x,y\right)$ of factors $x$ and $y$ we define the following constraints:
\begin{flalign}
    \left(x=0\right) &\Rightarrow && \left(ab^w_\texttt{bvmul}\left(x,y\right) = 0\right)
        &\label{align:refinement_approach:bvmul:simple:zero1}\\
    \left(y=0\right) &\Rightarrow && \left(ab^w_\texttt{bvmul}\left(x,y\right) = 0\right)
        &\label{align:refinement_approach:bvmul:simple:zero2}\\
    \left(x=1\right) &\Rightarrow && \left(ab^w_\texttt{bvmul}\left(x,y\right) = y\right)
        &\label{align:refinement_approach:bvmul:simple:one1}\\
    \left(y=1\right) &\Rightarrow && \left(ab^w_\texttt{bvmul}\left(x,y\right) = x\right)
        &\label{align:refinement_approach:bvmul:simple:one2}\\
    \left(x=-1\right) &\Rightarrow && \left(ab^w_\texttt{bvmul}\left(x,y\right) = -y\right)
        &\label{align:refinement_approach:bvmul:simple:neg1}\\
    \left(y=-1\right) &\Rightarrow && \left(ab^w_\texttt{bvmul}\left(x,y\right) = -x\right)
        &\label{align:refinement_approach:bvmul:simple:neg2}\\
    noov(x,y) &\Rightarrow && 
        \left( \neg x[w-1] \land \neg y[w-1] \right)
            \Rightarrow
            \left(ab^w_\texttt{bvmul}\left(x,y\right) \geq 0\right)
                &\label{align:refinement_approach:bvmul:simple:bothPos}\\
            && \land & \left( \neg x[w-1] \land y[w-1] \right)
            \Rightarrow
            \left(ab^w_\texttt{bvmul}\left(x,y\right) < 0\right)
                &\label{align:refinement_approach:bvmul:simple:oneNeg1}\\
            && \land & \left( x[w-1] \land \neg y[w-1] \right)
            \Rightarrow
            \left(ab^w_\texttt{bvmul}\left(x,y\right) < 0\right)
                &\label{align:refinement_approach:bvmul:simple:oneNeg2}\\
            && \land  & \left( x[w-1] \land y[w-1] \right)
            \Rightarrow
            \left(ab^w_\texttt{bvmul}\left(x,y\right) > 0\right)
                &\label{align:refinement_approach:bvmul:simple:bothNeg}\\
\end{flalign}
Equations (\ref{align:refinement_approach:bvmul:simple:zero1}) and (\ref{align:refinement_approach:bvmul:simple:zero2}) define the multiplication cases where one factor is zero and (\ref{align:refinement_approach:bvmul:simple:one1}) as well as (\ref{align:refinement_approach:bvmul:simple:one2}) define the cases where one factor is 1. Furthermore (\ref{align:refinement_approach:bvmul:simple:neg1}) and (\ref{align:refinement_approach:bvmul:simple:neg2}) define the negation cases.\\
Additionally we can make statements about the result's sign whenever we can be certain that no overflow is going to happen. For the cases where no overflow happens the sign behaviour of bitvector multiplication corresponds to the \enquote{common} sign behaviour and can therefore be split into 3 distinct cases:
\begin{itemize}
    \item Both factors are non-negative producing a non-negative result (\ref{align:refinement_approach:bvmul:simple:bothPos})
    \item Both factors are negative producing a positive result
    (\ref{align:refinement_approach:bvmul:simple:bothNeg})
    \item One of the factors is negative producing a negative result (\ref{align:refinement_approach:bvmul:simple:oneNeg1}), (\ref{align:refinement_approach:bvmul:simple:oneNeg2})
\end{itemize}{}

\subsection{Most significant digit based intervals}
Using the factors most significant digits, intervals can be defined which in turn can be used to assert intervals in which the multiplication's result must lie.
In a first step the signed multiplication $r\coloneqq ab_\texttt{bvmul}^w\left(x,y\right)$ is transformed into its unsigned version by using the absolute values:
\begin{flalign*}
    x' \leftarrow \texttt{ITE(}  & x[w-1],&\\
                                & -x,&\\
                                & x\texttt{)}&\\
    y' \leftarrow \texttt{ITE(}  & y[w-1],&\\
                                & -y,&\\
                                & y\texttt{)}&\\
    r' \leftarrow \texttt{ITE(} & x[w-1] \oplus y[w-1],&\\
                                & -umul^{2*w}(x',y')[w:], &\\
                                & umul^{2*w}(x',y')[w:] \texttt{)}&\\
\end{flalign*}
By asserting equality of $r$ and $r'$ it is then possible to reason about the results through bit shifting:
If $i$ is the most significant digit of $x'$ then $2^i\leq x' < 2^{i+1}$. Therefore $2^i*y' \leq r' < 2^{i+1}*y'$.
We now define a predicate $msd(x,i)$ which is true iff the most significant digit of $x$ is i.
\begin{definition}{$msd(x,i)$}

For some bitvector $x$ of width $w$ and an $i \in \llbracket 0,w \rrbracket$ we define:
\[
msd(x,i) \coloneqq  x[i]\land\bigwedge\limits_{j=i+1}^{w-1} \neg x[j]    
\]
\end{definition}

The previously presented results imply the following abstraction which must again distinguish overflow from no-overflow cases. For this we will initally use a double bit width (i.e. $2*w$ width) unsigned multiplication function as well as double bit width lower and upper bounds as defined below. We can then compare the necessary number of bits depending on the result of $noov$
$$
    lower(a, b, n)=
    \begin{cases}
        \texttt{ITE(} msd(a,0), b, 0 \texttt{)} & n=0\\
        \texttt{ITE(} msd(a,n), b \texttt{<<} n, lower(a, b, n-1) \texttt{)} & else
    \end{cases}
$$$$
    upper(a, b, n)=
    \begin{cases}
        b\texttt{<<}1 & n=0\\
        \texttt{ITE(} msd(a,n), b \texttt{<<} n+1, upper(a, b, n-1) \texttt{)} & else\\
    \end{cases}
$$$$
    noov(x',y') \Rightarrow lower(x',y',w)[w:] \leq r' \leq upper(x',y',w)[w:]
$$$$
     noov(x',y') \Rightarrow lower(y',x',w)[w:] \leq r' \leq upper(y',x',w)[w:]
$$$$
    \neg noov(x',y') \Rightarrow lower(x',y',w) \leq 0^w\cdot r' \leq upper(x',y',w)
$$$$
     \neg noov(x',y') \Rightarrow lower(y',x',w) \leq 0^w\cdot r' \leq upper(y',x',w)
$$

\subsection{Relations to other instructions}
Additionally to the previously described abstractions which all focused on relations between inputs and outputs of the specific instruction one can also look at relations between the given instruction invocation $ab_\texttt{bvmul}^w(\cdot,\cdot)$ and other invocations of the same or other instructions. This provides the solver with more high-level information and can therefore be useful in cases where relations between multiple instruction calls already lead to a contradiction without looking at the implementation details of the instructions.

For the multiplication instruction $ab_\texttt{bvmul}^w(x,y)$ we propose the following abstractions which become particularly interesting when combined with similar abstractions for instructions like \texttt{srem} or \texttt{sdiv} as described in the following sections
\[
    ab_\texttt{bvmul}^w(x,y) = ab_\texttt{bvmul}^w(y,x)
\]
\[
    y = ab_\texttt{sdiv}^w(ab_\texttt{smul}^w(x,y),x)
\]
\[
    x = ab_\texttt{sdiv}^w(ab_\texttt{smul}^w(x,y),y)
\]
For every bit width $w'<w$ which appears in a given instance we can further assert that:
\[
    ab_\texttt{bvmul}^w(x,y)[w':] = ab_\texttt{bvmul}^{w'}(x[w':],y[w':])
\]
\[
    ab_\texttt{bvmul}^w(x,y)[w':] = ab_\texttt{bvmul}^{w'}(y[w':],x[w':])
\]

\subsection{Bitwise iterative multiplication}
Oftentimes a multiplication of the entire factors is not necessary, but the multiplication of the first $n<w$ bits for bitwidth $w$ is sufficient to show a contradiction. In such cases it can be useful to iteratively add the logic for multiplication result bits until a contradiction is proved in order to \enquote{guide} the SAT solver on its way to the contradiction.
\dots
\section{Refining \texttt{sdiv}}
\subsection{Relations to other instructions}

\section{Refining \texttt{srem}}
\subsection{Relations to other instructions}
